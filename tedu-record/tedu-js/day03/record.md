# 6/3 正课
## Date
API:3句话
+ 1.单位  
    + FullYear  
    + Month  
    + Date  
    + Day  
    + Hours  
    + Minutes  
    + Seconds  
    + Milliseconds
+ 2.每个单位上都有一对儿get/set 方法  
    + 其中：getXXX() 专门获取单位的数值
        setXXX() 专门设置单位的数值
    + 比如：  
        Date.getDate();   
        Date.getFullYear();    
        Date.setDate();  
        Date.setFullYear();
    + 特例：  
        Day 没有set, 不能修改
+ 3.取值范围  
    Month: 0 ~ 11 计算机中的Month比现实小1，在取值和修改时，要修正  
    Date: 1~31  
    Day:  0~6  
    Hours: 0 ~ 23  
    Minutes/Seconds: 0 ~ 59  

+ 4.计算（2种）  
    1.两个日期对象可相减，结果为毫秒差  
    2.对任意单位做加减(3步）：  
    + 1.获得单位上的当前值  


## Error
程序执行过程中，导致程序无法正常执行的异常情况，只要程序发生错误，就会中断错误  
错误处理：即使程序发生错误，也保证不会中断退出的机制  
如何发生错误的正确代码：  
try {
    可能发生错误的正确代码
} catch(err){
    一旦发生错误，就自动执行的错误处理代码
}  
其中：err是错误对象；错误发生时，自动创建并封装错误信息的对象。  
效率：放在try{} catch(err) {} 中执行的代码，效率略有降低。  
解决：用if else 代替try catch  
错误类型：  
    syntaxError： 语法错误  
    ReferenceError: 引用错误  
    RangeError: 范围错误  参数超范围
    typeError: 类型错误  错误的使用了（）【】{}
    URIError: Uri错误
    EvalError: Eval错误

## Function
什么是：保存一段可重用的代码段的对象
何时：只要一段代码可能反复使用时都要封装为函数，反复调用函数
如何：  
+ 创建（3种）：
    + 直接量： function name(参数列表){ //函数执行过程中，需要使用外部条件参与运算的时候 需要穿参数
        函数体
        return 返回值  //调用者需要函数的执行结果时，需要返回值
    } //缺点 会被声明提前，打乱程序的执行顺序

    + 赋值： var func = function( 参数列表 ){
        函数体
        返回值
    }// 优点： 不会被声明提前，提前的仅仅是变量  
    // 揭示：函数其实也是一个引用类型的对象，函数名其实只是一个普通的变量，函数名通过地址引用对象  
    // function: 创建一个函数的意思

    + 使用 new : var fun = new Function();
+ 重载（overload)  
什么是：相同的函数名，不同参数列表的多个函数，在调用时，可根据传入的参数不同，自动选择匹配的函数执行  
为什么：减少API的数量，减少调用者的负担  
何时：只要一项任务，可能根据传入参数的不同，执行不同的流程时；  
如何：  
    + 问题: js语法默认不支持重载，因为不允许多个函数名同时存在  
    + arguments: 在函数调用时，自动创建的保存所有传入函数的参数值的类数组对象 
    + arguments vs array:  
        + 相同： 下标，length，遍历
        + 不同： 类型不同，API不通用  
    + 何时：重载：参数不确定时
    +
+ 匿名函数：
定义函数时，不指定函数的名称  
    + 何时：一个函数只使用一次时  
    + 为什么： 节约内存  
    + 垃圾回收： 引擎会释放不再使用的对象的内存空间  
    + 为什么：内存空间大小是有限的，系统都会自动释放不再被使用的对象，为后续新对象释放更多的空间  
    + 垃圾回收器：  
        专门统计并回收内存中不再被使用对象的小程序 。如何： 
        + 1.垃圾回收器伴随主程序启动而启动，在后台伴随主程序运行而运行
        + 2.垃圾回收器会记录每个对象被几个变量引用着
        + 3.只要一个对象不再被任何变量引用，则垃圾回收器自动释放该对象
        + 4.只要一个大对象，不再被使用，应当主动赋值为null
    + 回调函数：定义函数后，自己不执行，交给别的函数，由别的函数控制调用和执行流程
    + 匿名函数自调：函数定义后，自己调用自己！  
        + 为什么：全局变量，用完，无法自动释放 
        + 解决： 禁止使用全局变量
        + 何时： 只有所有功能的代码，必须放在匿名函数自调中
        + 如何：(function(){ //dosthing ... })()
### 作用域
什么是？ 变量的可用范围  
为什么？保证内部的变量不会干扰/影响外部的程序  
包括（2种）：
+ 全局作用域：  
    保存全局变量：特点：随处可用，可重复使用
+ 函数作用域：  
    保存局部变量：特点：仅函数内部可用，不可重用
+ 函数的生命周期：
    + 1.程序开始执行前：
        + 创建执行环境栈（ECS），用于记录有多少函数正在调用的函数
        + 在ECS中记录首先调用的浏览器主程序（main）
        + 创建全局作用域对象window，保存main函数执行所需要的所有全局变量
    + 2.定义函数时
        + 用函数名定义变量
        + 创建函数对象保存函数的定义，函数名通过地址引用函数对象 
        + 函数对象的scope 属性，指回函数来自的作用域
    + 3.调用函数时
        + 在ECS中加入本次函数的调用记录
        + 为本次函数调用，创建函数作用域对象（活动对象AO）
        + 在活动对象中保存所有局部变量； 
        + 让AO的parent属性，指向函数的scope作用域对象
        + 调用过程中，变量的使用顺序：
            + 先在AO中使用局部变量
            + 没有才去全局找 
    + 4.调用后 
        + ECS中本次函数的调用记录，出栈
        + 导致函数作用域AO释放
        + 导致AO中局部变量释放

### 作用域链（scope chain）
什么是：由多级对象逐级引用形成的链式结构  
保存着所有变量  
控制着变量的使用顺序（先局部，后全局）

## Closure 闭包 （极其重要）
什么是： 即重用变量，又保护变量不被污染的一种机制  
为什么：全局变量和局部变量都有不可兼顾的优缺点  
全局：  
+ 优点：可反复使用
+ 缺点：随处可用，容易被污染
局部：
+ 优点：仅函数内可用，不会被污染
+ 缺点：不可被重用  

何时：今后只要希望一个变量即可重用，又不会被污染  
如何（3步）：
+ 用外层函数包裹受保护的变量和内层函数对象
+ 将内层函数对象返回到外部
+ 使用者调用外层函数，获得内层函数
如何形成：外层函数调用后，外层函数的函数作用域对象AO无法释放，被内层函数拽着
缺点：闭包比普通函数占用更多的内存空间  
解决：如果闭包不再使用，应尽快释放， 将引用闭包结构的变量赋值为null

### 面向对象（OOP）
什么是：程序中描述一个现实中一个具体事物的属性和功能的程序结构  
什么是面向对象： 程序中都是用对象来描述现实中的具体事物，再按需调用对象的方法，访问对象的属性值   
为什么：当要管理的数据非常多时，如果单独管理每项数据，极其不利于维护和使用。且不符合现实。  
如何：面向对象3大特点： 封装、继承、多态

